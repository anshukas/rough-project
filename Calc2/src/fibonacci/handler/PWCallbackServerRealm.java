/*package fibonacci.handler;import java.io.IOException;import java.security.Principal;import java.util.Iterator;import javax.security.auth.callback.Callback;import javax.security.auth.callback.CallbackHandler;import javax.security.auth.callback.UnsupportedCallbackException;import org.apache.axis.MessageContext;import org.apache.ws.security.WSPasswordCallback;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.apache.catalina.*;import org.apache.catalina.realm.UserDatabaseRealm;import fibonacci.UserDatabaseRealmWSS;public class PWCallbackServerRealm implements CallbackHandler {	protected static Log log = LogFactory.getLog(PWCallbackServerRealm.class);	// the role we expect incoming WS calls to have	private String role = "webservice";	public void handle (Callback[] callbacks) throws IOException, UnsupportedCallbackException {		for (int i = 0; i < callbacks.length; i++) {			if (callbacks[i] instanceof WSPasswordCallback) {				WSPasswordCallback pc = (WSPasswordCallback) callbacks[i];				log.info("identifier: "+pc.getIdentifer()+", usage: "+pc.getUsage());				if (pc.getUsage() == WSPasswordCallback.USERNAME_TOKEN) {					// for passwords sent in digest mode we need to provide the password,					// because the original one can't be un-digested from the message					Realm realm = getRealm();					UserDatabaseRealmWSS myRealm = (UserDatabaseRealmWSS) realm;					String pwd = myRealm.getPasswordWSS(pc.getIdentifer());					// we can throw either of the two Exception types if authentication fails					if (pwd == null)						throw new IOException("insufficient credentials provided");					// this will throw an exception if the passwords don't match					pc.setPassword(pwd);				} else if (pc.getUsage() == WSPasswordCallback.USERNAME_TOKEN_UNKNOWN) {					// for passwords sent in cleartext mode we can compare passwords directly					Realm realm = getRealm();					Principal principal = realm.authenticate(pc.getIdentifer(), pc.getPassword());					log.info("principal: "+principal);					// we can throw either of the two Exception types if authentication fails					if ((principal == null) || (! realm.hasRole(principal, role)))						throw new IOException("insufficient credentials provided");				}			} else {				throw new UnsupportedCallbackException(callbacks[i], "Unrecognized Callback");			}		}	}    // The following method is Tomcat-specific to retrieve the currently active Realm.    // For this to work, Axis must be declared a "privileged" web app. That is done by    // setting the "privileged" attribute to "true" in TOMCAT_HOME/conf/Catalina/localhost/axis.xml    // If that file doesn't exist, create a minimal one containing just    // <Context path="/axis" docBase="axis" debug="5" privileged="true" />	protected Realm getRealm() {		Server server = ServerFactory.getServer();		log.info("server: "+server);			// this assumes the Container is "Catalina"		Service service = server.findService("Catalina");		log.info("service: "+service);		Engine engine = (Engine) service.getContainer();		log.info("engine: "+engine);		Host host = (Host) engine.findChild(engine.getDefaultHost());		log.info("host: "+host);		// The code in the following line should find the Axis context,		// but it did not work for me, so we iterate through all contexts to find it.		// Context context = (Context) host.findChild("axis");		// The code assumes that the Axis context is named "axis".		Context context = null;		Container[] contexts = host.findChildren();		for (int ctx=0; ctx<contexts.length; ctx++) {			// The following code assumes that the Axis context is in a directory named "axis".			if ("axis".equals(((Context) contexts[ctx]).getDocBase()))				context = (Context) contexts[ctx];		}		log.info("context: "+context);		// missing here: check for context == null		Realm realm = context.getRealm();		log.info("realm: "+realm.getInfo());		return realm;	}}*/